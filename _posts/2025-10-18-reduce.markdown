---
layout: post
title: "Implement `Array.prototype.reduce`"
date: 2025-10-18 19:43:00 +0800
categories: javascript, typescript, coding
math: true
---

# Question

Implement `Array.prototype.reduce`, a class method for arrays that "reduces"
elements in an array by calling the callback function on each element of the array
and passing forward the accumulated value of the return value from the preceding
element. The final return result is the single accumulated value of running the reducer
across all elements of the array.

[MDN Docs for Reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
[ECMAScript Docs for Reduce](https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reduce)

## Solution

```typescript
interface Array<T> {
  myReduce<U>(
    callbackFn: (
      previousValue: U,
      currentValue: T,
      currentIndex: number,
      array: T[],
    ) => U,
    initialValue?: U,
  ): U;
}

Array.prototype.myReduce = function (callbackFn, initialValue) {
  const noInitialValue = initialValue === undefined;
  const len = this.length;

  if (noInitialValue && len === 0) {
    throw new TypeError("Reduce of empty array with no initial value");
  }

  let accumulator = noInitialValue ? this[0] : initialValue;
  let startingIndex = noInitialValue ? 1 : 0;
  for (let i = startingIndex; i < len; i++) {
    if (Object.hasOwn(this, i)) {
      accumulator = callbackFn(accumulator, this[i], i, this);
    }
  }
  return accumulator;
};
```

## Write-up

If you hadn't read the specification, I believe you might not have known that
the callbackFn actually receives four arguments. These four arguments are
`accumulator`, `currentValue`, `currentIndex` and `array`.

Another key behaviour is that, if there is no initialValue supplied to reduce,
the initialValue will be set to the first element of the array, and the iteration
proceeds from the second element of the array.

And by extension, if there is no initialValue, and the array is empty, this behaviour
would result in an error which we must throw.

Knowing these key points, we can proceed with implementation.

I didn't know this prior, but an Array is actually an Object in Javascript, meaning
we can make use of Object.hasOwn to skip sparse values of an array, and only call
the callbackFn on actual values, e.g. `[1, 2, , 3]`, doing a hasOwn check first allows
us to handle the case of sparse arrays.

Another thing to keep in mind is that in general, our reduce function should not
mutate the array, while the callbackFn can technically still can. In order to minimize
the effect of mutation, our implementation has certain points which you can highlight
to the interviewer to show that you have thought about this issue.

The first is that, we use `const` to define our length of the array. This means the
range of elements we are processing is fixed before our first callback is called.
In the event that new elements are appended to the array, they will not be visited.

With the way the for loop is set up too, elements that are deleted after the call to
`reduce` begins will not be visited. Elements that are deleted before they are visited
will not be visited either.
